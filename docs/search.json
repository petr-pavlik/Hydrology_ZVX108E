[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ZVX108E Hydrology",
    "section": "",
    "text": "Introduction\nThe ZVX108E Hydrology taught at the Czech University of Life Sciences is an introductory undergraduate course with students of various scientific background, many of whom do not possess knowledge of any programming language yet. Hence we introduce the R programming language which serves for decades as a great tool for scientific data processing, statistical evaluation, visualization and reporting. The choice of R over other tools is opinionated. R is told to be “developed by statisticians for statisticians” and such as fits perfectly well into the workflow of hydrological data processing. We believe it is more straightforward to learn than Python and does not main students with plethora of environments and incomparable versions. There is a saying “Python is the second best language for everything” and we as authors fully agree. Since the course only contains six practical sessions, oriented to various parts of hydrology, we focus on the basic and merit.\nThis text was created with the use of 4.2.2 and namespaces of following packages:\nReproduction of all the materials should be possible using the same versions."
  },
  {
    "objectID": "index.html#data-and-companion-structure",
    "href": "index.html#data-and-companion-structure",
    "title": "ZVX108E Hydrology",
    "section": "Data and companion structure",
    "text": "Data and companion structure"
  },
  {
    "objectID": "intro.html#doporučená-literatura",
    "href": "intro.html#doporučená-literatura",
    "title": "1  Úvod",
    "section": "1.1 Doporučená literatura",
    "text": "1.1 Doporučená literatura\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "01_R.html#r-as-scientific-calculator",
    "href": "01_R.html#r-as-scientific-calculator",
    "title": "2  Introduction to R language",
    "section": "2.1 R as scientific calculator",
    "text": "2.1 R as scientific calculator\n\nArithmetic operations\n\n\nCode\n1 + 2           # addition\n1 - 2           # subtraction \n1 / 2           # division\n1 * 2           # multiplication\n1 %% 2          # integer division\n1 %/% 2         # modulo oprator\n\n\n\n\nSpecial values\nR is familiar with the concept of \\(\\pm\\infty\\), hence -Inf and Inf values are at disposal. You will get them most probably as results from computation heading to \\(\\frac{\\pm1}{0}\\) numerically. There are other special values like NULL (null value), NA (not assigned) and NaN (not a number). The concept of not assigned is one that is particularly important, since it has significant impact on the computed result ({(code-mean-rm?)}).\n\n\nCode\nx <- seq(1:10)             # general sequence of numbers\nx[c(5,6)] <- NA            # change some elements to not assigned\nprint(x)\n\n\n [1]  1  2  3  4 NA NA  7  8  9 10\n\n\nCode\nmean(x)                    # without removal\n\n\n[1] NA\n\n\nCode\nmean(x, na.rm = TRUE)      # and with removal\n\n\n[1] 5.5\n\n\n\n\nMatrix operations\nFor the purpose of following examples let’s use an arbitrary matrix \\(M\\) and a vectors \\(U\\) and \\(V\\).\n\\[\nA = \\left(\\begin{matrix}\n2x& - 3y& &= 3\\\\\n& - 2y& + 4z &= 9\\\\\n2x& + 13y& + 9z&= 10\n\\end{matrix}\\right),\\\\\n\\tag{2.1}\\]\n\\[\nU = \\begin{pmatrix}\n1\\\\\n-3\\\\\n8\\\\\n\\end{pmatrix},\nV = \\begin{pmatrix}\n1\\\\\n-3\\\\\n8\\\\\n\\end{pmatrix}\n\\tag{2.2}\\]\nSolving a system of linear equations {Equation 2.1} is a one-liner:\n\n\nCode\nA <- matrix(data = c(2, -3, 0, 0, -2, 4, 2, 13, 9), nrow = 3, byrow = TRUE)\nB <- c(3, 9, 10)\nsolve(A, B)\n\n\n[1]  0.5304878 -0.6463415  1.9268293"
  },
  {
    "objectID": "01_R.html#r-as-programming-language",
    "href": "01_R.html#r-as-programming-language",
    "title": "2  Introduction to R language",
    "section": "2.2 R as programming language",
    "text": "2.2 R as programming language\n\n2.2.1 Variables and name conventions\nIt is possible. We highly discourage using interpunction in naming, like the Czech translation of the term “variable” - proměnná. Most programmers use either camelNotation or snake_notation for naming purposes. Obviously the R is case-sensitive so camelNotation and CamelNotation are two different things.\n\n\n2.2.2 Functions\nYou can define own functions using the function() construct. If you work in RStudio, just type fun and tabulate a snippet from the IDE help. The action produces {(code-function-snippet?)}.\n\n\nCode\nname <- function(variables) {\n  \n}\n\n\nname is the name of the function we would like to create and variables are the arguments of that function. Space between the {and } is called a body of a function and contains all the computation which is invoked when the function is called.\nLet’s put Here an example of creating own function to calculate weighted mean\n\\[\n\\dfrac{1}{n}\\sum\\limits_{i=1}^{n} x_iw_i,\n\\] where \\(x_iw_i\\) are the individual weighted measurements.\nWe define a simple function for that purpose and run an example.\n\n\nCode\nw_mean <- function(x, w = 1/length(x)) {\n  1/1/length(x)*sum(x)\n}\nw_mean(1:10)\n\n\n[1] 5.5\n\n\nWe can test if we get the same result as the primitive function from R using all.equal() statement.\n\n\nCode\nall.equal(w_mean(1:10), mean(1:10))\n\n\n[1] TRUE\n\n\nAny argument without default value in the function definition has to be provided on function call. You can frequently see functions with the possibility to specify ... a so-called three dot construct.\n\n\n2.2.3 Data types\nThe basic types are logical, integer, numeric, complex, character and raw. There are some additional types which we will encounter like Date. Since R is dynamically typed, it is not necessary for the user to declare variables before using them. Also the type changes wihout notice based on the stored values, where the chain goes from the least complex to the most. The summary is in the following table\n\n\nCode\nTRUE    # logical, also T as short version\n\n\n[1] TRUE\n\n\nCode\n1L      # integer\n\n\n[1] 1\n\n\nCode\n1.2     # numeric\n\n\n[1] 1.2\n\n\nCode\n1+3i    # complex\n\n\n[1] 1+3i\n\n\nCode\n\"A\"     # character, also 'A'\n\n\n[1] \"A\"\n\n\n\n\n2.2.4 Data structures\n\nVectors\nAtomic vectors are single-type linear structures. They can contain elements of any type, from logical, integer, numeric, complex, character.\n\n\nCode\n```{r}\n#| label: test-code-annotation\nV <- vector(mode = \"numeric\", length = 0) # empty numeric vector creation\nV[1] <- \"A\"\n```\n\n\n\n\nMatrices and arrays\nIf the object has more than one dimension, it is treated as an array. A special type of array is a matrix. Both object types have accompanying functions like colSums(), rowMeans().\n\n\nCode\nM <- matrix(0, nrow = 1, ncol = 1) # empty matrix creation\nM[1, 1] <- 1                       # add single value at origin\nM[, 1] <- 0 \nM[1, 0] <- 0\n\ncolMeans(M) \n\n\n[1] 0\n\n\nCode\nrowSums(M)\n\n\n[1] 0\n\n\nIt is possible to have matrices containing any data type, e.g.\n\\[\nM = \\left(\\begin{matrix}\nA & B\\\\\nC & D\n\\end{matrix}\\right),\\qquad\nN = \\left(\\begin{matrix}\n\\mathrm{TRUE} & \\mathrm{FALSE}\\\\\n\\mathrm{FALSE} & \\mathrm{TRUE}\n\\end{matrix}\\right)\n\\]\n\n\n\n\n\nData frames\ndata.frame structure is the workhorse of elementary data processing. It is a possibly heterogenic table-like structure, allowing storage of multiple data types (even other structures) in different columns. A column in any data frame is called a variable and row represents a single observation. If the data suffice this single condition, we say they are in tidy format. Processing tidy data is a big topic withing the R community and curious reader is encouraged to follow the development in tidyverse package ecosystem.\n\n\nCode\nthaya <- data.frame(date = NA, \n                    runoff = NA, \n                    precipitation = NA) # new empty data.frame with variables 'date', 'runoff', 'precipitation' and 'temperature'\n#thaya$runoff <- rnorm(100, 1, 2)\n\n\n\n\nLists\nList is the most general basic data structure. It is possible to store vectors, matrices, data frames and also other lists within a list. List structure does not pose any limitations on the internal objects lengths.\n\n\nCode\nl <- list() # empty list creation \nl[\"A\"] <- 1\nprint(l)\n\n\n$A\n[1] 1\n\n\nCode\nl$A <- 2\nprint(l)\n\n\n$A\n[1] 2\n\n\n\n\nOther objects\nAlthough R is intended as functional programming language, more than one object oriented paradigm is implemented in the language. As new R users we encounter first OOP system in functions like summary and plot, which represent so called S3 generic functions. We will further work with S4 system when processing geospatial data using proxy libraries like sf and terra. The OOP is very complex and will not be further discussed within this text. For further study we recommend OOP sections in Advanced R by Hadley Wickham.\n\n\n\n\n\n\n2.2.5 Conditions\nA condition in code creates branching of computation. Placing a condition creates at least two options from which only one is to be satisfied. The condition is created either by if()/ifelse() or switch() construct. We can again call for a snippet from RStudio help resulting in\n\n\nCode\nif (condition) {\n  \n}\n\nswitch (object,\n  case = action\n)\n\n\n\n\n2.2.6 Cycles1\n\nfor cycle\nProbably the most common cycle is used when you know the number of iterations prior to calling. The iteration is therefore inherently finite.\n\n\nCode\nfor (variable in vector) {\n  \n}\n\nfor(i in seq_along)\n\n\n\n\nwhile cycle\nwhile is used in when it is impossible to state how many times something should be repeated. The case is rather in the form while some condition is or is not met, repeat what is inside the body. It is also used in intentionally infinite loop e.g. operating systems.\n\n\nrepeat cycle\nIn the cases when we need the repetition at least once, we will evaluate the code inside until a condition is met.\n\n\nCode\nrepeat({\n  x <- rnorm(1)\n  cat(x)\n  if(x > 0) break\n})\n\n\n0.9857716\n\n\n\n\n2.2.6.1 break and next\nThere are two statements which controls the iteration flow. Anytime break is called, the rest of the body is skipped and the loop ends. Anytime next is called, the rest of the body is skipped and next iteration is started.\n\n\n\n2.2.7 Exercise\n\ncreate a sequence of numbers calling\nWhat type is NA, why would you say is it?"
  },
  {
    "objectID": "02_statistics.html#hydrological-data",
    "href": "02_statistics.html#hydrological-data",
    "title": "3  Statistical processing of hydrological data",
    "section": "3.1 Hydrological data",
    "text": "3.1 Hydrological data\nDatasets containing hydrological data are most commonly, although not exclusively, in tabular (rectangular) shape. There are some data sets.\nLet’s take a look at data from CAMELS (Addor et al. 2017) at https://gdex.ucar.edu/dataset/camels.html. It is a curated large sample data set, which was produced by the UCAR with the intention to\nThis dataset covers the same 671 catchments as the Large-Sample Hydrometeorological Dataset introduced by Newman et al. (2015). For each catchment, we characterized a wide range of attributes that influence catchment behavior and hydrological processes. Datasets characterizing these attributes have been available separately for some time, but comprehensive multivariate catchment scale assessments have so far been difficult, because these datasets typically have different spatial configurations, are stored in different archives, or use different data formats. By creating catchment scale estimates of these attributes, our aim is to simplify the assessment of their interrelationships.\nTopographic characteristics (e.g. elevation and slope) were retrieved from Newman et al. (2015). Climatic indices (e.g., aridity and frequency of dry days) and hydrological signatures (e.g., mean annual discharge and baseflow index) were computed using the time series provided by Newman et al. (2015). Soil characteristics (e.g., porosity and soil depth) were characterized using the STATSGO dataset and the Pelletier et al. (2016) dataset. Vegetation characteristics (e.g. the leaf area index and the rooting depth) were inferred using MODIS data. Geological characteristics (e.g., geologic class and the subsurface porosity) were computed using the GLiM and GLHYMPS datasets.\n\n\nCode\n#ts <- readr::read_csv(\"data/\")"
  },
  {
    "objectID": "02_statistics.html#data",
    "href": "02_statistics.html#data",
    "title": "3  Statistical processing of hydrological data",
    "section": "3.2 Data",
    "text": "3.2 Data\nLet’s start with processing the data, that we will use within this chapter\n\n\nCode\ndata_03463300 <- read.fwf(file = \"./data/03463300_streamflow_qc.txt\", \n                          widths = c(8, 4, 2, 2, 8, 4), \n                          header = FALSE)\n\nnames(data_03463300) <- c(\"id\", \"yr\", \"mon\", \"day\", \"discharge\", \"cat\")\n\ndata_03463300$mon <- gsub(x = as.character(data_03463300$mon), \n                          pattern = \" \", \n                          replacement = \"0\")\ndata_03463300$day <- gsub(x = data_03463300$day, \n                          pattern = \" \",\n                          replacement = \"0\")\ndata_03463300$date <- paste(data_03463300$yr, \n                            data_03463300$mon, \n                            data_03463300$day, sep = \"-\")\n\nwith(data_03463300, \n     plot(x = , y = , type = \"l\", \n          frame.plot = FALSE))"
  },
  {
    "objectID": "02_statistics.html#aggregation-and-summation",
    "href": "02_statistics.html#aggregation-and-summation",
    "title": "3  Statistical processing of hydrological data",
    "section": "3.3 Aggregation and summation",
    "text": "3.3 Aggregation and summation\nThese functions are based on grouping. In hydrology, the natural groups involve - stations/basins, decades/years/months, groundwater regions, etc.\n\n3.3.1 Box-plot\nWhen we want\n\n\nCode\nstation <- read.delim(\"./data/6242910_Q_Day.Cmd.txt\", skip = 36, header = TRUE, sep = \";\", col.names = c(\"date\", \"time\", \"value\"))\nstation$date <- as.Date(station$date, format = \"%Y-%m-%d\")\n\nstation_agg <- aggregate(station$value ~ as.factor(data.table::month(station$date)), \n                         FUN = \"quantile\", \n                         probs = c(0.1, 0.25, 0.5, 0.75, 0.9))\nnames(station_agg) <- c(\"Month\", \"Discharge\")\npar(font.main = 1, \n    adj = 0.1, \n    xaxs = \"i\", \n    yaxs = \"i\")\nboxplot(data = station_agg, \n        Discharge ~ Month, \n        main = \"Distribution of discharge in months\", \n        frame = FALSE, \n        ylim = c(0,20), \n        xlab = \"\", \n        ylab = bquote(Discharge), font.main = 1)\n\n\n\n\n\n\n\n3.3.2 Q-Q plot\n\n\nCode\npar(font.main = 1, \n    adj = 0.1, \n    xaxs = \"i\", \n    yaxs = \"i\")\nplot(quantile(rnorm(1000), probs = 1:100/100),\nquantile(rnorm(1000), probs = 1:100/100), frame = FALSE, pch = 20)\nabline(0, 1, col = \"red\")\n\n\n\n\n\n\n\n3.3.3 Exceedance curve\n\n\n3.3.4 Frequency distribution curve"
  },
  {
    "objectID": "02_statistics.html#correlation-and-autocorrelation",
    "href": "02_statistics.html#correlation-and-autocorrelation",
    "title": "3  Statistical processing of hydrological data",
    "section": "3.4 Correlation and autocorrelation",
    "text": "3.4 Correlation and autocorrelation\n\\[\n\\rho_{X, Y} = \\dfrac{\\mathrm{cov}(X,Y)}{\\sigma_X\\sigma_Y}\n\\] \\[\n\\rho_{X,X}\n\\]"
  },
  {
    "objectID": "02_statistics.html#hydrological-indices",
    "href": "02_statistics.html#hydrological-indices",
    "title": "3  Statistical processing of hydrological data",
    "section": "3.5 Hydrological indices",
    "text": "3.5 Hydrological indices\n\n3.5.1 Runoff coefficient\nThe concept of runoff coefficient comes from the presumption, that over long-time period\n\\[\n\\varphi [-] = \\dfrac{R\\:[\\mathrm{mm}]}{P\\:[\\mathrm{mm}]}\n\\] where \\(R\\) represents runoff and \\(P\\) precipitation in long term.\n\n\n\n\nAddor, N., A. J. Newman, N. Mizukami, and M. P. Clark. 2017. “The CAMELS Data Set: Catchment Attributes and Meteorology for Large-Sample Studies.” Hydrology and Earth System Sciences 21 (10): 5293–313. https://doi.org/10.5194/hess-21-5293-2017."
  },
  {
    "objectID": "03_gis.html#whiteboxtools",
    "href": "03_gis.html#whiteboxtools",
    "title": "4  GIS in Hydrology",
    "section": "4.1 WhiteboxTools",
    "text": "4.1 WhiteboxTools\nWithin this introduction we use WhiteboxTools, a modern and advanced geospatial package, which contains ~450 tools and functions. The advantage of using WBT is in capability of inducing command line functions from within R."
  },
  {
    "objectID": "03_gis.html#watershed-delineation",
    "href": "03_gis.html#watershed-delineation",
    "title": "4  GIS in Hydrology",
    "section": "4.2 Watershed delineation",
    "text": "4.2 Watershed delineation\nThe process of delineation is the first step in basin description. One simply has to delineate the domain\nThe step-by-step process involves:\n- acquiring digital elevation model of area\n- pit and sink removal\n- flow accumulation calculation - flow direction calculation - outlet identification - delineation towards specified outlet"
  },
  {
    "objectID": "03_gis.html#geostatistics",
    "href": "03_gis.html#geostatistics",
    "title": "4  GIS in Hydrology",
    "section": "4.3 Geostatistics",
    "text": "4.3 Geostatistics\n\n4.3.1 River morphology statistics\nUnder the term river morphology we understand the description of the shape of river channels. Hydrologist utilize indices such as stream length, Strahler order"
  },
  {
    "objectID": "03_gis.html#session",
    "href": "03_gis.html#session",
    "title": "4  GIS in Hydrology",
    "section": "4.4 Session",
    "text": "4.4 Session\n\nStart with downloading DEM of specified area."
  },
  {
    "objectID": "04_interpolation.html#inverse-distance-weighting",
    "href": "04_interpolation.html#inverse-distance-weighting",
    "title": "5  Interpolation",
    "section": "5.1 Inverse distance weighting",
    "text": "5.1 Inverse distance weighting\n\\[\nZ_p = \\dfrac{\\sum\\limits_{i=1}^{n}\\dfrac{z_i}{d_i^P}}{\\sum\\limits_{i=1}^{n}\\dfrac{1}{d_i^P}}\n\\]\nLet’s create an arbitrary spatial domain"
  }
]